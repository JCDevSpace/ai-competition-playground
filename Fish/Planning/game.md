# Games

## Data Definition

As a reminder, we define a GameState and Move as: 

    A GameState is a (Board, List[Player], {Player, Set[Position]}, Int, {Player, Int})
    
    The GameState object represents all the data need to run the fish game.
    players penguins are on the board.
     
    The Board keeps track of the tiles and number of fish on those tiles,
    
    The List[Player] keeps information about the players in the game_state, and it is in the order in which they play.
    
    The {Player, List[Position]} keeps track of where the player's penguins are.
    
    The Int represents the index of the player whose turn it is this is in the range of 0 to len(players)-1.
    
    Finally, the {Player, Int} represents each players current score.
    
    The Data Definition of a Move is:
    
    A Move is a (Player, Position, Position) where the Player represents who is making the move and the first Position 
    is the starting Position of their penguin, and the second Position is the end Position

 
A Game is a (GameState, List[Game])

Where the GameState represents the current state of the Game, and the List of Games represent the 
possible future states generated by each possible valid Move.
 
If the List[Game] is empty, then we know that the game is over. 

At each node in the tree of the Game, the node will contain the current GameState 
and list of all of the Games which represent the possible children. 
The first node of the Game will be the starting state 
of the board which is the state after all players have placed their penguins.

A child of a Game is a resulting Game when a 
Player makes one of their valid Moves (including the placement of a penguin at the start of the game) 
or is skipped for having no valid Moves. 

If a Player has no valid Moves and other players still have valid Moves,
the resulting children will be the a list of a single Game. The GameState of which
will be the same in all but the "turn" field when compared to the GameState of it's parent. 
The turn field  will advance to show that the player has been skipped 
(including wrapping around back to 0 if they were the last player in the rotation). 

If no players have possible Moves, the list of the child Games will be empty, this represents the end state of a Game. 

The advancing turn counter ensures that even when a player is skipped, it is always obvious which player's turn it is.  

Additionally, the score of each player is saved within the data structure meaning it is always at hand. 


## Interface 

// Returns the list of valid moves which can be made by the player who's turn it is     
Game.get_valid_moves_from_state(): -> List[Move]


// This returns the list of all possible future Games one turn away from here       
Game.get_next_games() -> List[Games]

//Returns the current GameState of this step of the Game        
Game.get_current_state() -> GameState


// Returns whether or not this Game is over     
Game.is_over() -> Boolean


// returns the resulting game if this sequence of moves were executed in the order provided
Game.get_resulting(List[Move]) -> Game

//Returns the resulting Game given a single Move    
Game.get_result(Move) -> Game

//Returns the best move for the current player given a heuristic function which evaluates all reachable GameStates one Move away.                 
Game.best_move(  (Function(GameState) -> Int ) ) -> Move




